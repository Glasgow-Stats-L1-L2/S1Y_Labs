[["index.html", "S1Y Lab 2 1 Visualizing Data 1.1 Intended Learning Outcomes 1.2 Visualising Data: Great British Bake Off (GBBO) 1.3 Building plots 1.4 Counting categories 1.5 One numerical variable 1.6 Grouped numerical variables 1.7 Two numerical variables 1.8 Two numerical variables and a categorical variable", " S1Y Lab 2 1 Visualizing Data 1.1 Intended Learning Outcomes Be able to create graphical summaries of data using the ggplot2 library 1.2 Visualising Data: Great British Bake Off (GBBO) In this lab, we will revisit the Great British Bake Off dataset which we worked with in Lab 1. Refer to Lab 1 for a reminder of the dataset structure if you need to. 1.2.1 Reading data in The file ratings_seasons_Lab2.csv contains data on the first 10 series (2010-2019) and includes all the additional variables we created in Lab 1. You can load the data in like Lab 1 below: library(tidyverse) ratings &lt;- read_csv(&quot;https://raw.githubusercontent.com/Glasgow-Stats-L1-L2/S1Y_Data/main/ratings_seasons.csv&quot;) We can also read the ratings_seasons.csv file in locally to RStudio if we download a copy of the file onto our own device. You can find this file in the 'Lab 1' section on Moodle. Once you have downloaded and saved the csv file to your device (it is usually a good idea to save data in the same place as your R script), we will then have to set the working directory (where your file is located). In order to do this go to: Session &gt; Set Working Directory &gt; Choose Directory... The file explorer will then open, and you can locate the folder your data is stored in. Once this has been found, select 'Open\". Once our working directory has been set, we now have to read our data into RStudio. We can do this using the following command ratings &lt;- read_csv(&#39;ratings_seasons_Lab2.csv&#39;) We will once again have to change the variables series, episode and channel to factors which we can do using the code below. ratings &lt;- ratings %&gt;% mutate(series = as.factor(series), episode = as.factor(episode), channel = as.factor(channel)) 1.3 Building plots There are multiple approaches to data visualisation in R; in this course we will use the popular package ggplot2, which is part of the larger tidyverse collection of packages. A grammar of graphics (the \"gg\" in \"ggplot\") is a standardised way to describe the components of a graphic. ggplot2 uses a layered grammar of graphics, in which plots are built up in a series of layers. It may be helpful to think about any picture as having multiple elements that sit semi-transparently over each other. Figure 1 displays the steps to create a simple scatterplot using this layered approach. First, the plot space is built (layer 1); the variables are specified (layer 2); the type of visualisation (known as a geom) that is desired for these variables is specified (layer 3) - in this case geom_point() is called to visualise individual data points; a second geom is added to include a line of best fit (layer 4), the axis labels are edited for readability (layer 5), and finally, a theme is applied to change the overall appearance of the plot (layer 6). Figure 1.1: Steps to create a layered plot Importantly, each layer is independent and independently customisable. For example, the size, colour and position of each component can be adjusted. The use of layers makes it easy to build up complex plots step-by-step, and to adapt or extend plots from existing code. Using the concept of building up a plot by layers, we will describe some specific plot types. Different types of data require different types of plots, so the following sections are organised by data type. The ggplot2 cheat sheet is a great resource to help you find plots appropriate to your data, based on how many variables you're plotting and what type they are. The examples below all use the GBBO data, but each plot communicates something different. We don't expect you to memorise all of the plot types or the methods for customising them, but it will be helpful to try out the code in the examples below for yourself, changing values to test your understanding. 1.4 Counting categories 1.4.1 Bar plot If you want to count the number of things per category, you can use geom_bar(). You only need to provide an x mapping to geom_bar() because by default geom_bar() uses the number of observations in each group of x as the value for y, so you don't need to tell it what to put on the y-axis. ggplot(ratings, aes(x = channel)) + geom_bar() Notice that layers are added using the plus + symbol at the end of the previous line, not at the start of the next line. For example if you make this mistake: ggplot(ratings, aes(x = channel)) + geom_bar() ...it will produce an empty 'base layer' and then an error like this: ## Error: ## ! Cannot use `+` with a single argument ## ℹ Did you accidentally put `+` on a new line?     Inspect the code below and try running it layer by layer to figure out how things like the order of the columns and their labels change. ggplot(ratings, aes(x = channel, fill = channel)) + geom_bar() + labs(title=&quot;Number of episodes of GBBO broadcast on each channel&quot;)+ # adds a plot title ylab(&quot;Number of Episodes&quot;)+ # adds an axis label theme(legend.position = &quot;none&quot;)+ # removes the legend scale_x_discrete( # change axis label name = &quot;Broadcast Channels (in chronological order)&quot;, # change to chronological order limits = c(&quot;BBC2&quot;, &quot;BBC1&quot;, &quot;C4&quot;), # change labels labels = c(&quot;BBC 2&quot;, &quot;BBC 1&quot;, &quot;Channel 4&quot;) )   Copy and edit the code above to produce a bar plot showing the number of episodes in each series of GBBO Solution ggplot(ratings, aes(x = series, fill = series)) + geom_bar() + labs(title=&quot;Number of episodes of GBBO broadcast in each series&quot;)+ # adds a plot title ylab(&quot;Number of Episodes&quot;)+ # adds an axis label xlab(&quot;Series&quot;)+ # adds an axis label theme(legend.position = &quot;none&quot;)+ # removes the legend scale_x_discrete( # change to categorical labels limits = c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;), # change labels labels = c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;) ) 1.4.2 Column plot If your data already have a column with the number you want to be the height of each bar or column, you can use geom_col() to plot it. Recall that the ratings data contains the variable viewers_7day which contains the number of viewers in the 7 days after each episode which we can plot as the height of each bar/column by setting y=viewers_7day. But what will we use to define where they are plotted on the x-axis? After considering the values contained in the variable series and/or episode complete this statement: Neither the values in series or episode can be used to define x=: TRUEFALSE Explanation select(ratings,series,episode) ## # A tibble: 94 × 2 ## series episode ## &lt;fct&gt; &lt;fct&gt; ## 1 1 1 ## 2 1 2 ## 3 1 3 ## 4 1 4 ## 5 1 5 ## 6 1 6 ## 7 2 1 ## 8 2 2 ## 9 2 3 ## 10 2 4 ## # ℹ 84 more rows # Notice that neither series nor episode contain unique values, which would be necessary to define the position on the x-axis for each of the columns with height equal to the ratings (viewers_7day) So before we can create the column plot, we need to create a new variable: Run this code to create a new variable ep_id which is the unique index indicating the chronological order of each episode (using the row_number() function and the fact that it's the same as the order it appears in the ratings data). ratings &lt;- ratings %&gt;% mutate(ep_id = row_number()) Now we have the two variables we need to make the column plot. Inspect and run this code to produce the plot below. ggplot(ratings, aes(x = ep_id, y = viewers_7day, fill = series)) + geom_col() + labs(title=&quot;7-Day Viewers across All Series/Episodes&quot;)+ ylab(&quot;Number of viewers (millions)&quot;)+ # adds an axis label xlab(&quot;Episode Index&quot;)+ # adds an axis label scale_fill_discrete(name=&quot;Series&quot;) # set the name of the legend 1.4.3 Test your understanding Here is a small data table. country population island Northern Ireland 1,895,510 Ireland Wales 3,169,586 Great Britain Republic of Ireland 4,937,786 Ireland Scotland 5,466,000 Great Britain England 56,550,138 Great Britain What geom would you use to plot the population for each of the 5 countries? geom_bargeom_col What mapping would you use? aes(x = country, y = population) aes(x = population, y = country) aes(x = country) aes(x = island) aes(y = population) What geom would you use to plot the number of countries on each island? geom_bargeom_col What mapping would you use? aes(x = country, y = population) aes(x = population, y = country) aes(x = country) aes(x = island) aes(y = population) 1.5 One numerical variable If you have a numerical variable, like the number of views 7 days after each broadcast, you can use geom_histogram() or geom_density() to show the distribution. Just like geom_bar() you are only required to specify the x variable. 1.5.1 Histogram A histogram splits the data into \"bins\" along the x-axis and shows the count of how many observations are in each bin along the y-axis. ggplot(ratings, aes(x = viewers_7day)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Figure 1.2: Histogram of ratings. You should always set the binwidth or number of bins to something meaningful for your data (otherwise you get an annoying message, like the one above). You might need to try a few options before you find something that looks good and conveys the meaning of your plot. Try changing the values of binwidth and bins below to see what works best. # adjust width of each bar ggplot(ratings, aes(x = viewers_7day)) + geom_histogram(binwidth = 2) # adjust number of bars ggplot(ratings, aes(x = viewers_7day)) + geom_histogram(bins = 5) Finally, the default style of grey bars is a bit boring, so you can change that by setting the fill and colour, as well as using scale_x_continuous() to update the axis labels. Adapt and run this code to control the appearance of the histogram ggplot(ratings, aes(x = viewers_7day)) + geom_histogram(binwidth = 1, boundary = 0, fill = &quot;white&quot;, color = &quot;black&quot;) + scale_x_continuous(name = &quot;Number of viewers 7 days after broadcast (in millions)&quot;) Solution ggplot(ratings, aes(x = viewers_7day)) + geom_histogram(binwidth = 1, boundary = 0, fill = &quot;red&quot;, # Can change the colour here for the bars color = &quot;black&quot;) + # Can change the colour of the outline of the bars scale_x_continuous(name = &quot;Number of viewers 7 days after broadcast (in millions)&quot;) 1.6 Grouped numerical variables There are several ways to compare numerical data across groups. Which you choose depends on what point you are trying to make with the plot. 1.6.1 Subdividing distributions In previous plots, we have used fill purely for visual reasons, e.g., we have changed the colour of the histogram bars to make them look nicer. However, you can also use fill to represent another variable so that the colours become meaningful. Setting the fill aesthetic in the mapping will produce different coloured bars for each category of the fill variable, in this case issue_category. ggplot(ratings, aes(x = viewers_7day, fill = channel)) + geom_histogram(binwidth = 1, color = &quot;black&quot;) Figure 1.3: Histogram with categories represented by fill. 1.6.2 Violin plot Another way to compare groups of continuous variables is the violin plot. This is like a density plot, but rotated 90 degrees and mirrored - the fatter the violin, the larger proportion of data points there are at that value. ggplot(ratings, aes(x = channel, y = viewers_7day)) + geom_violin() + ggtitle(&#39;scale = &quot;area&quot;&#39;) Figure 1.4: The default violin plot gives each shape the same area. Set scale='count' to make the size proportional to the number of observations. ggplot(ratings, aes(x = channel, y = viewers_7day)) + geom_violin(scale = &quot;count&quot;) + ggtitle(&#39;scale = &quot;count&quot;&#39;) 1.6.3 Boxplot Boxplots serve a similar purpose to violin plots. They don't show you the shape of the distribution, but rather some statistics about it. The middle line represents the median; half the data are above this line and half below it. The box encloses the 25th to 75th percentiles of the data, so 50% of the data falls inside the box. The \"whiskers\" extending above and below the box extend 1.5 times the height of the box, although you can change this with the coef argument. The points show outliers -- individual data points that fall outside of this range. ggplot(ratings, aes(x = channel, y = viewers_7day)) + geom_boxplot() Figure 1.5: Basic boxplot.     1.6.4 Test your understanding How would you create plot A? geom_box()geom_boxplot()geom_violin()geom_violinplot() How would you create plot B? geom_box()geom_boxplot()geom_violin()geom_violinplot() What does the mapping look like for both plots? aes(x = series, y = viewers_7day, fill = viewers_7day) aes(x = series, y = viewers_7day, colour = viewers_7day) aes(x = series, y = viewers_7day, fill = series) aes(x = series, y = viewers_7day, colour = series) Which series had the highest ratings? 12345678910 Which channel brodcast the series with the highest ratings? (You need to think back to answer this question) BBC 1BBC 2Channel 4 1.7 Two numerical variables When you want to see how two numerical variables are related, set one as the x-axis and the other as the y-axis. For example, what if we want to see the changes in ratings over the episodes/series in chronological order. 1.7.1 Scatterplot The function to create a scatterplot is called geom_point(). ggplot(ratings, aes(x = ep_id, y = viewers_7day)) + geom_point() Figure 1.6: Scatterplot with geom_point(). Edit and run the above code to join up the points in the scatterplot by adding the function + geom_line and then modify the code further to remove the points Solution ggplot(ratings, aes(x = ep_id, y = viewers_7day)) + geom_point()+ geom_line()+ ggtitle(&quot;Scatterplot with both points and lines&quot;) ggplot(ratings, aes(x = ep_id, y = viewers_7day)) + geom_line()+ ggtitle(&quot;Scatterplot with just lines&quot;) These plots show each individual episodes' ratings and are perhaps more detailed than we need. If we were just interested in looking at the ratings across series, then we could create summaries for each series and plot these. Examine and run this code to produce a lineplot of the average ratings for each series avg_ratings &lt;- ratings %&gt;% select(series, episode, viewers_7day) %&gt;% group_by(series) %&gt;% summarise(avg_viewers_7day = mean(viewers_7day)) %&gt;% ungroup() ggplot(avg_ratings, aes(x = series, y = avg_viewers_7day, group=1)) + geom_point() + geom_line() + ggtitle(&quot;Great British Bake Off Average Ratings&quot;) Optional: Why do we need group=1 Because the x values in aes() are a factor, by default geom_line() treats each unique x value as a separate group and tries to connect points only inside each group. Setting group=1 in aes() ensures that all values are treated as one group (and therefore connected by lines using geom_line()).   1.8 Two numerical variables and a categorical variable It is often the case that we are interested in relationships between more then two variables. The code below illustrates how to build more complex graphical summaries, in this case number of viewers of the first and last episode in each series. You do not need to produce this plot but have a look and see if you can follow the code that is used to create it. plot_data &lt;- ratings %&gt;% select(series, episode, viewers_7day) %&gt;% group_by(series) %&gt;% filter(episode == 1 | episode == max(as.numeric(episode))) %&gt;% mutate(episode = recode(episode, &quot;1&quot; = &quot;first&quot;, .default = &quot;last&quot;)) %&gt;% ungroup() ggplot(plot_data, aes(x = series, y = viewers_7day, color = episode, group = episode )) + geom_point() + geom_line() + ggtitle(&quot;Great British Bake Off Finales Get More Viewers than Premiers&quot;) + labs(color = &quot;Episode&quot;) "],["group-exercises.html", "2 Group Exercises 2.1 BFRSS Survey Questions", " 2 Group Exercises In this group exercise, we will revisit the BFRSS Survey Questions data from Lab 1 (a reminder of this data and instructions to download can be found below) 2.1 BFRSS Survey Questions The Behavioral Risk Factor Surveillance System (BRFSS) is an annual telephone survey of 350,000 people in the United States. As its name implies, the BRFSS is designed to identify risk factors in the adult population and report emerging health trends. For example, respondents are asked about their diet and weekly physical activity, possible tobacco use, and even their level of healthcare coverage. The BRFSS Web site contains a complete description of the survey, including the research questions that motivate the study and many interesting results derived from the data. You will focus on a random sample of 20,000 people from the BRFSS survey conducted in 2000. While there are over 200 variables in this data set, you will work with a small subset. Load the data set of 20,000 observations into the object cdc and look at what it contains by running the following code. It may take a couple of minutes for the data to load, depending on your internet connection, so be patient! source(&quot;http://www.openintro.org/stat/data/cdc.R&quot;) str(cdc) Make a scatterplot of weight (in pounds) versus desired weight (in pounds). Describe the relationship between these two variables. It may be helpful to add the command +geom_abline() onto the end of your plot code, which adds in the y=x line. Make a histogram of age. Choose a suitable number of bins for your plot. Describe the distribution of age. Consider a new variable: the difference between desired weight (wtdesire) and current weight (weight). Create this new variable by subtracting the two columns in the data frame and assigning them to a new object called wdiff. Using a side-by-side box plot, determine if men tend to view their weight differently than women. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
