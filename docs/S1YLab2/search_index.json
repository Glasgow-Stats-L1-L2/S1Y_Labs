[["index.html", "S1Y Lab 2 1 Visualizing Data 1.1 Intended Learning Outcomes 1.2 Visualising Data: Great British Bake Off (GBBO) 1.3 Building plots 1.4 Counting categories 1.5 One numerical variable 1.6 Grouped numerical variables 1.7 Two numerical variables 1.8 Optional: Two numerical variables and a categorical variable", " S1Y Lab 2 1 Visualizing Data 1.1 Intended Learning Outcomes Be able to create graphical summaries of data using the ggplot2 library 1.2 Visualising Data: Great British Bake Off (GBBO) In this lab, we will revisit the Great British Bake Off dataset which we worked with in Lab 1. Refer to Lab 1 for a reminder of the dataset structure if you need to. 1.2.1 Reading data in The file ratings_seasons_Lab2.csv contains data on the first 10 series (2010-2019). You can load the data in like Lab 1 below: library(tidyverse) ratings &lt;- read_csv(&quot;https://raw.githubusercontent.com/Glasgow-Stats-L1-L2/S1Y_Data/main/ratings_seasons_Lab2.csv&quot;) We can also read the ratings_seasons.csv file in locally to RStudio if we download a copy of the file onto our own device. You can find this file in the 'Lab 1' section on Moodle. Once you have downloaded and saved the csv file to your device (it is usually a good idea to save data in the same place as your R script), we will then have to set the working directory (where your file is located). In order to do this go to: Session &gt; Set Working Directory &gt; Choose Directory... The file explorer will then open, and you can locate the folder your data is stored in. Once this has been found, select 'Open\". Once our working directory has been set, we now have to read our data into RStudio. We can do this using the following command ratings &lt;- read_csv(&#39;ratings_seasons_Lab2.csv&#39;) We will once again have to change the variables series, episode and channel to factors which we can do using the code below. ratings &lt;- ratings %&gt;% mutate(series = as.factor(series), episode = as.factor(episode), channel = as.factor(channel)) 1.3 Building plots There are multiple approaches to data visualisation in R; in this course we will use the popular package ggplot2, which is part of the larger tidyverse collection of packages. A grammar of graphics (the \"gg\" in \"ggplot\") is a standardised way to describe the components of a graphic. ggplot2 uses a layered grammar of graphics, in which plots are built up in a series of layers. It may be helpful to think about any picture as having multiple elements that sit semi-transparently over each other. Figure 1 displays the steps to create a simple scatterplot using this layered approach. First, the plot space is built (layer 1); the variables are specified (layer 2); the type of visualisation (known as a geom) that is desired for these variables is specified (layer 3) - in this case geom_point() is called to visualise individual data points; a second geom is added to include a line of best fit (layer 4), the axis labels are edited for readability (layer 5), and finally, a theme is applied to change the overall appearance of the plot (layer 6). Figure 1.1: Steps to create a layered plot Importantly, each layer is independent and independently customisable. For example, the size, colour and position of each component can be adjusted. The use of layers makes it easy to build up complex plots step-by-step, and to adapt or extend plots from existing code. Using the concept of building up a plot by layers, we will describe some specific plot types. Different types of data require different types of plots, so the following sections are organised by data type. The ggplot2 cheat sheet is a great resource to help you find plots appropriate to your data, based on how many variables you're plotting and what type they are. The examples below all use the GBBO data, but each plot communicates something different. We don't expect you to memorise all of the plot types or the methods for customising them, but it will be helpful to try out the code in the examples below for yourself, changing values to test your understanding. 1.4 Counting categories 1.4.1 Bar plot If you want to count the number of things per category, you can use geom_bar(). You only need to provide an x mapping to geom_bar() because by default geom_bar() uses the number of observations in each group of x as the value for y, so you don't need to tell it what to put on the y-axis. ggplot(ratings, aes(x = channel)) + geom_bar() Notice that layers are added using the plus + symbol at the end of the previous line, not at the start of the next line. For example if you make this mistake: ggplot(ratings, aes(x = channel)) + geom_bar() ...it will produce an empty 'base layer' and then an error like this: ## Error: ## ! Cannot use `+` with a single argument. ## ℹ Did you accidentally put `+` on a new line?     Inspect the code below and try running it layer by layer to figure out how things like the order of the columns and their labels change. ggplot(ratings, aes(x = channel, fill = channel)) + geom_bar() + labs(title=&quot;Number of episodes of GBBO broadcast on each channel&quot;)+ # adds a plot title ylab(&quot;Number of Episodes&quot;)+ # adds an axis label theme(legend.position = &quot;none&quot;)+ # removes the legend scale_x_discrete( # change axis label name = &quot;Broadcast Channels (in chronological order)&quot;, # change to chronological order limits = c(&quot;BBC2&quot;, &quot;BBC1&quot;, &quot;C4&quot;), # change labels labels = c(&quot;BBC 2&quot;, &quot;BBC 1&quot;, &quot;Channel 4&quot;) )   Copy and edit the code above to produce a bar plot showing the number of episodes in each series of GBBO Solution ggplot(ratings, aes(x = series, fill = series)) + geom_bar() + labs(title=&quot;Number of episodes of GBBO broadcast in each series&quot;)+ # adds a plot title ylab(&quot;Number of Episodes&quot;)+ # adds an axis label xlab(&quot;Series&quot;)+ # adds an axis label theme(legend.position = &quot;none&quot;)+ # removes the legend scale_x_discrete( # change to categorical labels limits = c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;), # change labels labels = c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;) ) 1.5 One numerical variable If you have a numerical variable, like the number of views 7 days after each broadcast, you can use geom_histogram() or geom_density() to show the distribution. Just like geom_bar() you are only required to specify the x variable. 1.5.1 Histogram A histogram splits the data into \"bins\" along the x-axis and shows the count of how many observations are in each bin along the y-axis. ggplot(ratings, aes(x = viewers_7day)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with ## `binwidth`. Figure 1.2: Histogram of ratings. The histogram will look different depending on the number of bins you have. Too many bins will leave some empty spaces (like in the figure above). Not enough bins won't give you as much information as you could have. You can control the number of bins with two arguments (see Lab 1 if you don't remember what an argument is) of the geom_histogram function: bins: lets you specify the number of bins you wish for. You shouldn't have more bins than observations. binwidth: lets you specify how large you wish the bins to be. Both achieve the same results, for some data it might be better to work with bins, for others with binwidth. You should always set the binwidth or number of bins to something meaningful for your data (otherwise you get an annoying message, like the one above). You might need to try a few options before you find something that looks good and conveys the meaning of your plot. Try changing the values of binwidth and bins below to see what works best. # adjust width of each bar ggplot(ratings, aes(x = viewers_7day)) + geom_histogram(binwidth = 2) # adjust number of bars ggplot(ratings, aes(x = viewers_7day)) + geom_histogram(bins = 5) Finally, the default style of grey bars is a bit boring, so you can change that by setting the fill and colour, as well as using scale_x_continuous() to update the axis labels. Adapt and run this code to control the appearance of the histogram ggplot(ratings, aes(x = viewers_7day)) + geom_histogram(binwidth = 1, boundary = 0, fill = &quot;white&quot;, color = &quot;black&quot;) + scale_x_continuous(name = &quot;Number of viewers 7 days after broadcast (in millions)&quot;) Solution ggplot(ratings, aes(x = viewers_7day)) + geom_histogram(binwidth = 1, boundary = 0, fill = &quot;red&quot;, # Can change the colour here for the bars color = &quot;black&quot;) + # Can change the colour of the outline of the bars scale_x_continuous(name = &quot;Number of viewers 7 days after broadcast (in millions)&quot;) 1.6 Grouped numerical variables There are several ways to compare numerical data across groups. Which you choose depends on what point you are trying to make with the plot. 1.6.1 Subdividing distributions In previous plots, we have used fill purely for visual reasons, e.g., we have changed the colour of the histogram bars to make them look nicer. However, you can also use fill to represent another variable so that the colours become meaningful. Setting the fill aesthetic in the mapping will produce different coloured bars for each category of the fill variable, in this case channel. ggplot(ratings, aes(x = viewers_7day, fill = channel)) + geom_histogram(binwidth = 1, color = &quot;black&quot;) Figure 1.3: Histogram with categories represented by fill. 1.6.2 Boxplot Boxplots serve a similar purpose to violin plots. They don't show you the shape of the distribution, but rather some statistics about it. The middle line represents the median; half the data are above this line and half below it. The box encloses the 25th to 75th percentiles of the data, so 50% of the data falls inside the box. The \"whiskers\" extending above and below the box extend 1.5 times the height of the box, although you can change this with the coef argument. The points show outliers -- individual data points that fall outside of this range. ggplot(ratings, aes(x = channel, y = viewers_7day)) + geom_boxplot() Figure 1.4: Basic boxplot.     1.6.3 Test your understanding How would you create the plot? geom_box()geom_boxplot()geom_plot() What does the mapping look like for the plot? aes(x = series, y = viewers_7day, fill = series) aes(x = series, y = viewers_7day, colour = series) aes(x = series, y = viewers_7day, colour = viewers_7day) aes(x = series, y = viewers_7day, fill = viewers_7day) Which series had the highest ratings? 12345678910 Which channel brodcast the series with the highest ratings? (You need to think back to answer this question) BBC 1BBC 2Channel 4 1.7 Two numerical variables When you want to see how two numerical variables are related, set one as the x-axis and the other as the y-axis. For example, what if we want to see the changes in ratings over the episodes/series in chronological order. 1.7.1 Scatterplot The function to create a scatterplot is called geom_point(). It creates a plot where we assign a point to each observation. The coordinates of the point (i.e. where it lies) are given by its x and y values. ggplot(ratings, aes(x = ep_id, y = viewers_7day)) + geom_point() Figure 1.5: Scatterplot with geom_point(). Edit and run the above code to join up the points in the scatterplot by adding the function + geom_line() and then modify the code further to remove the points Solution ggplot(ratings, aes(x = ep_id, y = viewers_7day)) + geom_point()+ geom_line()+ ggtitle(&quot;Scatterplot with both points and lines&quot;) ggplot(ratings, aes(x = ep_id, y = viewers_7day)) + geom_line()+ ggtitle(&quot;Scatterplot with just lines&quot;) 1.7.1.1 Grouped by a categorical variable These plots show each individual episodes' ratings and are perhaps more detailed than we need. If we were just interested in looking at the ratings across series, then we could create summaries for each series and plot these. This basically entails grouping the episode by the series they belong to, and then compute a summary statistic (the mean in this case) on the grouped data. To do this, we can use the group_by(x) function. This creates a new dataset where observations are grouped according to the variable x. We can then apply summarise() to the new dataset. Let us create this dataset, containing the average rating for each series. We select the columns series, episode, viewers_7day because they are the ones containing the information we need. avg_ratings &lt;- ratings %&gt;% select(series, episode, viewers_7day) %&gt;% group_by(series) %&gt;% summarise(avg_viewers_7day = mean(viewers_7day)) %&gt;% ungroup() Notice the last line. ungroup() is used to make sure that future calculations will work on the dataset. Remember to always ungroup datasets. Examine the new dataset and its structure. View(avg_ratings) Now we can create a scatterplot of the average rating per series ggplot(avg_ratings, aes(x = series, y = avg_viewers_7day, group=1)) + geom_point() + geom_line() + ggtitle(&quot;Great British Bake Off Average Ratings&quot;) Optional: Why do we need group=1 Because the x values in aes() are a factor, by default geom_line() treats each unique x value as a separate group and tries to connect points only inside each group. Setting group=1 in aes() ensures that all values are treated as one group (and therefore connected by lines using geom_line()). 1.8 Optional: Two numerical variables and a categorical variable Optional: work though this example It is often the case that we are interested in relationships between more then two variables. The code below illustrates how to build more complex graphical summaries, in this case number of viewers of the first and last episode in each series. You do not need to produce this plot but have a look and see if you can follow the code that is used to create it. plot_data &lt;- ratings %&gt;% select(series, episode, viewers_7day) %&gt;% group_by(series) %&gt;% filter(episode == 1 | episode == max(as.numeric(episode))) %&gt;% mutate(episode = recode(episode, &quot;1&quot; = &quot;first&quot;, .default = &quot;last&quot;)) %&gt;% ungroup() ggplot(plot_data, aes(x = series, y = viewers_7day, color = episode, group = episode )) + geom_point() + geom_line() + ggtitle(&quot;Great British Bake Off Finales Get More Viewers than Premiers&quot;) + labs(color = &quot;Episode&quot;) What did we do? filter(episode == 1 | episode == max(as.numeric(episode))) : we select the first and last episode of each series. Since different series will have a different number of episodes we use the function max(). The vertical bar \"|\" stands for \" inclusive or\". mutate(episode = recode(episode, \"1\" = \"first\", .default = \"last\")) : the function \"recode()\" transforms each entry that is equal to 1 in the word \"first\", and everything else (.default) in the word \"last\". You can change this function to give different names to the first and last episode of each series color=episode : we color the lines and points according to the value of episode (i.e. a color for the first episode and a color for the last) group=episode : to understand this read also the Optional: Why do we need group=1 above. In this case we want a separate line for each value of episode (i.e. a line for the first episode and a line for the last) What do you notice from the plot? Solution The views 7 days after the episode was aired are higher for the last episode in every series. People tend to watch the series finale more. "],["group-exercises.html", "2 Group Exercises 2.1 BFRSS Survey Questions", " 2 Group Exercises In this group exercise, we will revisit the BFRSS Survey Questions data from Lab 1 (a reminder of this data and instructions to download can be found below) 2.1 BFRSS Survey Questions The Behavioral Risk Factor Surveillance System (BRFSS) is an annual telephone survey of 350,000 people in the United States. As its name implies, the BRFSS is designed to identify risk factors in the adult population and report emerging health trends. For example, respondents are asked about their diet and weekly physical activity, possible tobacco use, and even their level of healthcare coverage. The BRFSS Web site contains a complete description of the survey, including the research questions that motivate the study and many interesting results derived from the data. You will focus on a random sample of 20,000 people from the BRFSS survey conducted in 2000. While there are over 200 variables in this data set, you will work with a small subset. Load the data set of 20,000 observations into the object cdc and look at what it contains by running the following code. It may take a couple of minutes for the data to load, depending on your internet connection, so be patient! source(&quot;http://www.openintro.org/stat/data/cdc.R&quot;) str(cdc) Make a scatterplot of weight (in pounds) versus desired weight (in pounds). Describe the relationship between these two variables. It may be helpful to add the command +geom_abline() onto the end of your plot code, which adds in the y=x line. Make a histogram of age. Choose a suitable number of bins for your plot. Describe the distribution of age. During Lab 1, we created a new variable wdiff, defined as the difference between desired weight, wtdesired, and weight. Add again this variable to the data frame ( if you don't remember how to do it, feel free to briefly revisit Lab 1). Now, using a side-by-side box plot, determine if there is a difference in wdiff between men and women. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
