[["index.html", "S1Y Lab 1 1 Part 1: Intro to R and RStudio 1.1 Intended Learning Outcomes 1.2 R and RStudio 1.3 RStudio Quickstart Guide 1.4 Credit where credit is due", " S1Y Lab 1 1 Part 1: Intro to R and RStudio 1.1 Intended Learning Outcomes Be introduced to R and RStudio Be able to load in packages Be able to get help for packages and functions Be able to create objects by writing and running R code 1.2 R and RStudio R is a programming language that you will write code in and RStudio is an Integrated Development Environment (IDE) which makes working in R easier. Think of it as knowing English and using a plain text editor like NotePad to write a book versus using a word processor like Microsoft Word. You could do it, but it would be much harder without things like spell-checking and formatting and you wouldn't be able to use some of the advanced features that Word has developed. In a similar way, you can use R without RStudio but we wouldn't recommend it. RStudio serves as a text editor, file manager, spreadsheet viewer, and more. The key thing to remember is that although you will do all of your work using RStudio for this course, you are actually using two pieces of software which means that from time-to-time, both of them may have separate updates. 1.2.1 OPTIONAL: Installing R and RStudio on your device You do not need to install R or RStudio on your own laptop or desktop computer. You can complete these labs on the universities PCs, and these already have R and RStudio installed. However, R and (basic) RStudio are free to download and install, and information is provided below if you wish to install both on your own device. If you already had R and/or RStudio installed, we recommend updating to the latest version before you work through this course. 1.2.2 Installing R The first step is to install R on your own device. This can be done for free from CRAN (the Comprehensive R Archive Network). R is available for Windows, Mac OS, Linux and some other less common operating systems. If you are using a Windows device, you can install the latest version of R at the link and click 'Download R-x.y.z for Windows. Once this is complete, run the installer and accept all default settings. If you are using a Mac OS device, you can install the latest version of R at the link and select the .pkg file. Once this has downloaded, open the file and complete the on-screen steps to finish installing R. 1.2.3 Installing RStudio Now that R is installed on your device, you are ready to download and install RStudio. To do this, go to RStudio and click on the link 'Install RStudio...', This should automatically detect what operating system your device is using, but do double check it says either for Windows or Mac OS (or another system you are using) - whichever is correct! The file may take a few seconds to download, but once it has launch the installer and follow the steps to complete the installation. You are now ready to use RStudio. Make sure you launch the RStudio app to complete the labs, rather than R. 1.3 RStudio Quickstart Guide The R software gives the computer the ability to process the R programming language. We will never use that software directly. Instead, we will use RStudio, an integrated development environment (IDE) which runs R for us via a graphical user interface (GUI) . To open RStudio from the University PCs: Open the \"Maths-Stats\" folder on the desktop. Open the \"RStudio\" programme from this folder. Alternativley, you can simply search for \"RStudio\" in the search bar. To create a text file (which we call an \"R script\") to write your R code in, select from the menu: File &gt; New File &gt; R Script To save the R script file, go to File &gt; Save A dialogue box will appear asking where on the computer you would like to save your file. Save this R script file by navigating to a drive letter (e.g. H: or M:) or to a USB stick you have brought with you and save it with a relevant filename, e.g. \"S1Y_Lab_1\". Once saved in a .R script file, you can use your code again, so there's no need to type it in a second time. If you close RStudio and then open it again, you can read in your code by going to File &gt; Open File... and find the code file from the location where you saved it. The RStudio IDE is arranged with four windows. Figure 1.1: The RStudio IDE By default, the upper left pane is the source pane, where you view, write, and edit code from files and view data tables in a spreadsheet format. When you first open RStudio, this pane won't display until we open a script file (like we did above) or load in some data. We 'run' (i.e. execute) code in the script file by selecting the row(s) we want to run and then clicking the Run icon OR by holding down the ctrl (or command in Mac) key and Enter at the same time. The results of executing the code (if any) appear in the lower left pane. The lower left pane is the console pane, where you can type in commands and view output messages. You can write code in the console to test it out. The code will run and can create objects in the environment, but the code itself won't be saved. You need to write your code into a script in the source pane to save it. The right panes have several different tabs that show you information about your code. The most used tabs in the upper right pane are the Environment tab and the Help tab. The environment tab lists some information about the object that you have defined in your code. We'll learn more about the Help tab in Section 2.2.5. In the lower right pane, the most used tabs are the Files tab for directory structure, the Plots tab for plots made in a script, the Packages tab for managing add-on packages (see Section 2.2), and the Viewer tab to display reports created by your scripts. You can change the location of panes and what tabs are shown under Preferences &gt; Pane Layout. 1.4 Credit where credit is due This introductory lab incorporates and adapts materials from: Nordmann, E. &amp; DeBruine, L. (2022) Applied Data Skills. v1.0. Retrieved from https://psyteachr.github.io/ads-v1/ doi: 10.5281/zenodo.6365077 and Hill, A. (2022) Data Visualization in the Tidyverse: The Great Tidy Plot Off. Retrieved from https://alison.netlify.app/uo-tidy-bakeoff "],["getting-started-using-rstudio.html", "2 Getting started using RStudio 2.1 Objects and the assign (&lt;-) operator (optional) 2.2 Packages and functions 2.3 Pipes (%&gt;%) 2.4 Getting help 2.5 Further Resources", " 2 Getting started using RStudio 2.1 Objects and the assign (&lt;-) operator (optional) A large part of working in R involves creating and manipulating objects. Objects contain stuff. That stuff can be numbers, words, or the result of operations and analyses. You assign content to an object using &lt;-, where the name of the new/updated object appears on the left and the data to be assigned to that object appear on the right. Run the following code in the console, but change the values of name and age to your own details and change christmas to a holiday or date you care about. name &lt;- &quot;Sara&quot; age &lt;- 22 today &lt;- Sys.Date() christmas &lt;- as.Date(&quot;2025-12-25&quot;) UK_nations &lt;- tibble(nation = c(&quot;Scotland&quot;,&quot;Wales&quot;, &quot;Northern Ireland&quot;, &quot;England&quot;), capital = c(&quot;Edinburgh&quot;, &quot;Cardiff&quot;, &quot;Belfast&quot;, &quot;London&quot;), population = c(5448000, 3132000, 1911000, 57106000)) You'll see that five objects now appear in the environment pane: name is character (text) data. In order for R to recognise it as character data, it must be enclosed in double quotation marks \" \". age is numeric data. In order for R to recognise this as a number, it must not be enclosed in quotation marks. today stores the result of the function Sys.Date(). This function returns your computer system's date. Unlike name and age, which are hard-coded (i.e., they will always return the values you enter), the contents of the object today will change dynamically with the date. That is, if you run that function tomorrow, it will update the date to tomorrow's date. christmas is also a date but it's hard-coded as a very specific date. It's wrapped within the as.Date() function that tells R to interpret the character string you provide as date rather than text. UK_nations - is a \"tibble\" which is basically a table of data (like the way a spreadsheet stores data in rows and columns). Almost always the data we are interested in will be in this type of object or a \"data frame\" which is very similar to a \"tibble\" (and can be converted to one using as_tibble()) Optional Extra Info on tibbles... ...see R for Data Science To print the contents of an object, type the object's name in the console and press enter. Print all five objects by typing: name age today christmas UK_nations Optional Extra Info on print()... Alternatively, the print() function can be used instead of just entering the objects name. One reason to use print() would be to force R to show all the elements of the object using the n= argument which controls how many elements to print. We'll use this function later in this lab. Finally, a key concept to understand is that objects can interact and you can save the results of those interactions in a new object. Run the following code to create these new objects, and then print the contents of each new object. age_in_10_years &lt;- age + 10 full_name &lt;- paste(name, &quot;Euzzor&quot;) how_long &lt;- christmas - today 2.1.1 The $ operator The dollar sign $ allows you to select items from an object, such as columns from a \"tibble\". The left-hand side of the $ is the object, and the right-hand side is the item. Use this code to extract the populations of the four UK nations from the UK_nations object and store it in a new object called populations then print the new object to check that it contains what you expect: populations &lt;- UK_nations$population populations If your item has multiple observations, you can specify which ones to return using square brackets [] and the position or a vector of positions. Use this code to get a list of the UK nations in the order they appear in the object UK_nations then create an object that contains just the population of Scotland and another object that contains the population of the other UK nations. Print the two objects you created to check that the code did what you expected UK_nations$nation Scotland_capital &lt;- UK_nations$capital[1] # select one observation rUK_capitals &lt;- UK_nations$capital[c(2,3,4)] # select multiple values using c() which creates a vector Scotland_capital rUK_capitals 2.1.2 Code comments In the above code we've used code comments and it's important to highlight how useful these are. You can add comments inside R code with the hash symbol #. R will ignore characters from the hash to the end of the line. 2.2 Packages and functions When you install R you will have access to a range of functions including options for data wrangling and statistical analysis. The functions that are included in the default installation are typically referred to as \"base R\" and you can think of them like the default apps that come pre-loaded on your phone. One of the great things about R, however, is that it is user extensible: anyone can create a new add-on that extends its functionality. There are currently hundreds of thousands of packages that R users have created to solve many different kinds of problems, or just simply to have fun. For example, there are packages for data visualisation, machine learning, interactive dashboards, web scraping, and playing games such as Sudoku. Add-on packages are not distributed with base R, but have to be downloaded and installed from an archive, in the same way that you would, for instance, download and install an app on your smartphone. The main repository where packages reside is called CRAN, the Comprehensive R Archive Network. There is an important distinction between installing a package and loading a package. 2.2.1 Installing a package This section on \"Installing a package\" is only relevant if you have R/RStudio installed on your own laptop/PC. You CANNOT install packages on the university PCs - all the packages you need are already installed. So, if you are using a computer in the lab, you can skip to the next section on \"Loading a package\") This is done using install.packages(). This is like installing an app on your phone: you only have to do it once and the app will remain installed until you remove it. For instance, if you want to use an app on your phone, you install it once from the App Store or Play Store; you don't have to re-install it each time you want to use it. Once you launch the app, it will run in the background until you close it or restart your phone. Likewise, when you install a package, the package will be available (but not loaded) every time you open up R. For example, to install the tidyverse package on your system: # Type this in the console pane install.packages(&quot;tidyverse&quot;) This package is the main package we will use throughout these labs for data wrangling, summaries, and visualisation. If you get a message that says something like package ‘tidyverse’ successfully unpacked and MD5 sums checked, the installation was successful. 2.2.2 Loading a package This is done using the library() function. This is like launching an app on your phone: the functionality is only there where the app is launched and remains there until you close the app or restart. For example, when you run library(rio) within a session, the functions in the package referred to by rio will be made available for your R session. The next time you start R, you will need to run library(rio) again if you want to access that package. For example, you can load the tidyverse package for your current R session as follows: library(tidyverse) You might get some red text when you load a package, this is normal. It is usually warning you that this package has functions that have the same name as other packages you've already loaded. 2.2.3 Using a function A function is a name that refers to some code you can reuse. We'll start by using functions that are provided for you in packages, but you can also write your own functions. After the function name, there is a pair of parentheses, which contain zero or more arguments. If you type a function into the console pane, it will run as soon as you hit enter. If you put the function in a script or R Markdown document in the source pane, it won't run until you run the script or run a code chunk. 2.2.4 Tidyverse tidyverse is a meta-package that loads several packages we'll be using in these labs, including: ggplot2, for data visualisation readr, for data import dplyr, for data manipulation 2.2.5 Function Help When you load the tidyverse package it automatically loads all of the above packages, however, it can be helpful to know which package a function comes from if you need to Google it. If a function is in \"base R\" or a loaded package, you can type ?function_name in the console to access the help file. At the top of the help it will give you the function and package name. If the package isn't loaded, use ?package_name::function_name or specify the package in the help() function. When you aren't sure what package the function is in, use the shortcut ??function_name. # if the package is loaded ?select help(&quot;select&quot;) # works whether or not the package is loaded ?dplyr::select help(&quot;select&quot;, package=&quot;dplyr&quot;) # shows a list of potentially matching functions ??select Function help is always organised in the same way. For example, look at the help for ?dplyr::select. At the top, it tells you the name of the function and its package in curly brackets, then a short description of the function, followed by a longer description. The Usage section shows the function with all of its arguments. If any of those arguments have default values, they will be shown like function(arg = default). The Arguments section lists each argument with an explanation. There may be a Details section after this with even more detail about the functions. The Examples section is last, and shows examples that you can run in your console window to see how the function works. 2.2.6 Arguments You can look up the arguments/options that a function has by using the help documentation. Some arguments are required, and some are optional. Optional arguments will often use a default (normally specified in the help documentation) if you do not enter any value. As an example, look at the help documentation for the function sample() which randomly samples items from a list. ?sample The help documentation for sample() should appear in the bottom right help panel. In the usage section, we see that sample() takes the following form: sample(x, size, replace = FALSE, prob = NULL) In the arguments section, there are explanations for each of the arguments. x is the list of items we want to choose from, size is the number of items we want to choose, replace is whether or not each item may be selected more than once, and prob gives the probability that each item is chosen. In the details section it notes that if no values are entered for replace or prob it will use defaults of FALSE (each item can only be chosen once) and NULL (all items will have equal probability of being chosen). Because there is no default value for x or size, they must be specified otherwise the code won't run. Let's try an example and just change the required arguments to x and size to ask R to choose 5 random letters (letters is a built-in vector of the 26 lower-case Latin letters). sample(x = letters, size = 5) ## [1] &quot;z&quot; &quot;v&quot; &quot;y&quot; &quot;w&quot; &quot;j&quot; Why are my letters different to your letters? sample() generates a random sample. Each time you run the code, you'll generate a different set of random letters (try it). The function set.seed() controls the random number generator - if you're using any functions that use randomness (such as sample()), running set.seed() will ensure that you get the same result (in many cases this may not be what you want to do). To get the same numbers we do, run set.seed(1242016) in the console, and then run sample(x = letters, size = 5) again. Now we can change the default value for the replace argument to produce a set of letters that is allowed to have duplicates. set.seed(8675309) sample(x = letters, size = 5, replace = TRUE) ## [1] &quot;t&quot; &quot;k&quot; &quot;j&quot; &quot;k&quot; &quot;m&quot; This time R has still produced 5 random letters, but now this set of letters has two instances of \"k\". Always remember to use the help documentation to help you understand what arguments a function requires. 2.2.7 Argument names In the above examples, we have written out the argument names in our code (i.e., x, size, replace), however, this is not strictly necessary. The following two lines of code would both produce the same result (although each time you run sample() it will produce a slightly different result, because it's random, but they would still work the same): sample(x = letters, size = 5, replace = TRUE) sample(letters, 5, TRUE) Importantly, if you do not write out the argument names, R will use the default order of arguments. That is for sample it will assume that the first value you enter is x. the second value is size and the third value is replace. If you write out the argument names then you can write the arguments in whatever order you like: sample(size = 5, replace = TRUE, x = letters) When you are first learning R, you may find it useful to write out the argument names as it can help you remember and understand what each part of the function is doing. However, as your skills progress you may find it quicker to omit the argument names and you will also see examples of code online that do not use argument names, so it is important to be able to understand which argument each bit of code is referring to (or look up the help documentation to check). In this course, we will always write out the argument names the first time we use each function. However, in subsequent uses they may be omitted. 2.2.8 Tab auto-complete One very useful feature of RStudio is tab auto-complete for functions (see Figure 2.1). If you write the name of the function and then press the tab key, RStudio will show you the arguments that function takes along with a brief description. If you press enter on the argument name it will fill in the name for you, just like auto-complete on your phone. This is incredibly useful when you are first learning R and you should remember to use this feature frequently. Figure 2.1: Tab auto-complete 2.3 Pipes (%&gt;%) Pipes (%&gt;%) allow you to send the output from one function straight into another function. Specifically, they send the result of the function before %&gt;% to be the first argument of the function after %&gt;%. It can be useful to translate the pipe as \"and then\". It's easier to show than tell, so let's look at an example. We could write the above code using pipes and some new functions from the tidyverse as follows: UK_nations %&gt;% select(nation) # pull out one variable Scotland_capital &lt;- UK_nations %&gt;% select(capital) %&gt;% # choose one variable slice(1) # then choose the first observation in that variable rUK_capitals &lt;- UK_nations %&gt;% filter(nation != &quot;Scotland&quot;) %&gt;% #choose observations that satisfy a condition select(capital) #then choose one variable&#39;s values of the subset of observations Scotland_capital rUK_capitals Optional Extra Info... Although the values in the objects Scotland_capital and rUK_capitals are the same using both sets of code, the \"types\" of objects they are depends on how they are produced (as shown in the different ways they are \"printed\"). We don't need to think too much about the different types of objects in this course. Also, we've the last code used functions select, slice and filter which are part of the dplyr package in tidyverse. We will introduce these functions as we need them, but if you want more information, see this overview, this chapter and/or this Cheat Sheet 2.4 Getting help You will feel like you need a lot of help when you're starting to learn. This won't really go away; it's impossible to memorise everything. The goal is to learn enough about the structure of R that you can look things up quickly. This is why we'll introduce specialised jargon in the glossary for each chapter; it's easier to google \"convert character to numeric in R\" than \"make numbers in quotes be actual numbers not words\". In addition to the function help described above, here's some additional resources you should use often. 2.4.1 Package reference manuals Start up help in a browser by entering help.start() in the console. Click on \"Packages\" under \"Reference\" to see a list of packages. Scroll down to the readxl package and click on it to see a list of the functions that are available in that package. 2.4.2 Googling If the function help doesn't help, or you're not even sure what function you need, try Googling your question. It will take some practice to be able to use the right jargon in your search terms to get what you want. It helps to put \"R\" or \"tidyverse\" in the search text, or the name of the relevant package, like ggplot2. 2.4.3 Vignettes Many packages, especially tidyverse ones, have helpful websites with vignettes explaining how to use their functions. Some of the vignettes are also available inside R. You can access them from a package's help page or with the vignette() function. # opens a list of available vignettes vignette(package = &quot;ggplot2&quot;) # opens a specific vignette in the Help pane vignette(&quot;ggplot2-specs&quot;, package = &quot;ggplot2&quot;) 2.5 Further Resources RStudio IDE Cheatsheet "],["part-2---analyzing-data.html", "3 Part 2 - Analyzing Data 3.1 Intended Learning Outcomes 3.2 Dealing with Data: Great British Bake Off (GBBO)", " 3 Part 2 - Analyzing Data 3.1 Intended Learning Outcomes Be introduced to key dplyr functions for data wrangling (part of the tidyverse) Be able to create numerical summaries of data Be able to create graphical summaries of data Be able to create objects by writing and running code in the console 3.2 Dealing with Data: Great British Bake Off (GBBO) The data set we will be looking at in this section refers to TV competition \"Great British Bake Off\" (often abbreviated to \"Bake Off\" or \"GBBO\"). Within each series, a group of amateur bakers compete against each other in a series of episodes, attempting to impress a group of judges with their baking skills. One contestant is eliminated in each episode, and the winner is selected from the contestants who reach the final. The first episode was aired on 17 August 2010, with its first four series broadcast on BBC Two, after which it moved to BBC One for the next three series. After its seventh series, it moved to Channel 4. 3.2.1 Reading data in The file ratings_seasons.csv contains data on the first 10 series (2010-2019). Open a script in RStudio (perhaps call it S1Y_Lab_1.R) and paste and run this code to read the data into RStudio library(tidyverse) ratings &lt;- read_csv(&quot;https://raw.githubusercontent.com/craigalexander/S1Y_Data/main/ratings_seasons.csv&quot;) Looking at our Environment, we can now see that the ratings data has now appeared! Reading in data on your device into RStudio We can also read the ratings_seasons.csv file in locally to RStudio if we download a copy of the file onto our own device. You can find this file in the 'Lab 1' section on Moodle. Once you have downloaded and saved the csv file to your device (it is usually a good idea to save data in the same place as your R script), we will then have to set the working directory (where your file is located). In order to do this go to: Session &gt; Set Working Directory &gt; Choose Directory... The file explorer will then open, and you can locate the folder your data is stored in. Once this has been found, select 'Open\". Once our working directory has been set, we now have to read our data into RStudio. We can do this using the following command ratings &lt;- read_csv(&quot;ratings_seasons.csv&quot;) 3.2.2 Looking at data Now that you've loaded some data, look the upper right hand window of RStudio, under the Environment tab. You will see the object ratings listed, along with the number of observations (rows) and variables (columns). This is your first check that you've read in the data correctly. Always look at your data once you've created or loaded it. Also look at it after each step that transforms your data. There are two main ways to look at your data: View() and str(). View() An intuitive way to look at the data is by using View() (uppercase 'V'), which opens up a data table in the console pane using a viewer that looks a bit like an Excel spreadsheet. This command can be useful in the console, but don't ever put this one in a script because it will create an annoying pop-up window when the user runs it. You can also click on an object in the Environment pane to open it in the same interface. You can close the tab when you're done looking at it; it won't remove the object containing the data. View(ratings) str() The funciton str() (short for \"structure\") shows the number of observations and variables and the datatype of those variables, e.g. \"num\" for an number, \"chr\" for a character string (and a lot more information that we don't need to know about!) str(ratings, give.attr=FALSE) #The argument give.attr=FALSE surpresses extra info ## spc_tbl_ [94 × 13] (S3: spec_tbl_df/tbl_df/tbl/data.frame) ## $ series : num [1:94] 1 1 1 1 1 1 2 2 2 2 ... ## $ episode : num [1:94] 1 2 3 4 5 6 1 2 3 4 ... ## $ uk_airdate : Date[1:94], format: &quot;2010-08-17&quot; &quot;2010-08-24&quot; ... ## $ viewers_7day : num [1:94] 2.24 3 3 2.6 3.03 2.75 3.1 3.53 3.82 3.6 ... ## $ viewers_28day : num [1:94] 7 3 2 4 1 1 2 2 1 1 ... ## $ network_rank : num [1:94] NA NA NA NA NA NA NA NA NA NA ... ## $ channels_rank : num [1:94] NA NA NA NA NA NA NA NA NA NA ... ## $ bbc_iplayer_requests: num [1:94] NA NA NA NA NA NA NA NA NA NA ... ## $ episode_count : num [1:94] 1 2 3 4 5 6 7 8 9 10 ... ## $ us_season : num [1:94] NA NA NA NA NA NA NA NA NA NA ... ## $ us_airdate : chr [1:94] NA NA NA NA ... ## $ channel : chr [1:94] &quot;BBC2&quot; &quot;BBC2&quot; &quot;BBC2&quot; &quot;BBC2&quot; ... ## $ ep_id : num [1:94] 1 2 3 4 5 6 7 8 9 10 ... Optional: other ways of looking at data It is always necessary to look at the data you are working with to get a good sense of what it contains, i.e. the different types of data contained in the data set and how much data you have. We used the str() function above to get information on the number of variables and observations and to list the variables together with the first few values they take. Alternatively we could use these functions: head(): shows the first 6 lines of the first few variables head(ratings) ## # A tibble: 6 × 13 ## series episode uk_airdate viewers_7day viewers_28day network_rank ## &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 2010-08-17 2.24 7 NA ## 2 1 2 2010-08-24 3 3 NA ## 3 1 3 2010-08-31 3 2 NA ## 4 1 4 2010-09-07 2.6 4 NA ## 5 1 5 2010-09-14 3.03 1 NA ## 6 1 6 2010-09-21 2.75 1 NA ## # ℹ 7 more variables: channels_rank &lt;dbl&gt;, bbc_iplayer_requests &lt;dbl&gt;, ## # episode_count &lt;dbl&gt;, us_season &lt;dbl&gt;, us_airdate &lt;chr&gt;, channel &lt;chr&gt;, ## # ep_id &lt;dbl&gt; glimpse(): gives a sideways version of the data. This is useful if the data is very wide (i.e. has lots of variables) and you can't easily see all of the columns/variables. It also tells you the data type of each column/variable in angled brackets after each column/variable name. glimpse(ratings) ## Rows: 94 ## Columns: 13 ## $ series &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3… ## $ episode &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3… ## $ uk_airdate &lt;date&gt; 2010-08-17, 2010-08-24, 2010-08-31, 2010-09-07, … ## $ viewers_7day &lt;dbl&gt; 2.24, 3.00, 3.00, 2.60, 3.03, 2.75, 3.10, 3.53, 3… ## $ viewers_28day &lt;dbl&gt; 7, 3, 2, 4, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1… ## $ network_rank &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ channels_rank &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ bbc_iplayer_requests &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ episode_count &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15… ## $ us_season &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ us_airdate &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ channel &lt;chr&gt; &quot;BBC2&quot;, &quot;BBC2&quot;, &quot;BBC2&quot;, &quot;BBC2&quot;, &quot;BBC2&quot;, &quot;BBC2&quot;, &quot;… ## $ ep_id &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15… By using any of the methods described above, answer these questions: How many variables does the data ratings contain? How many observations does ratings contain? In this lab we are interested in the ratings of each episode in the 7 day period after its broadcast. What variable contains this information? ratings series episode viewers_7day viewers_28day 3.2.3 Exploring data 3.2.3.1 Factors and categorical variables Before we proceed to explore the data any further we need to pause and think about two types of variables: numeric and categorical. Run this code again to see the variables in ratings str(ratings,give.attr=FALSE) ## spc_tbl_ [94 × 13] (S3: spec_tbl_df/tbl_df/tbl/data.frame) ## $ series : num [1:94] 1 1 1 1 1 1 2 2 2 2 ... ## $ episode : num [1:94] 1 2 3 4 5 6 1 2 3 4 ... ## $ uk_airdate : Date[1:94], format: &quot;2010-08-17&quot; &quot;2010-08-24&quot; ... ## $ viewers_7day : num [1:94] 2.24 3 3 2.6 3.03 2.75 3.1 3.53 3.82 3.6 ... ## $ viewers_28day : num [1:94] 7 3 2 4 1 1 2 2 1 1 ... ## $ network_rank : num [1:94] NA NA NA NA NA NA NA NA NA NA ... ## $ channels_rank : num [1:94] NA NA NA NA NA NA NA NA NA NA ... ## $ bbc_iplayer_requests: num [1:94] NA NA NA NA NA NA NA NA NA NA ... ## $ episode_count : num [1:94] 1 2 3 4 5 6 7 8 9 10 ... ## $ us_season : num [1:94] NA NA NA NA NA NA NA NA NA NA ... ## $ us_airdate : chr [1:94] NA NA NA NA ... ## $ channel : chr [1:94] &quot;BBC2&quot; &quot;BBC2&quot; &quot;BBC2&quot; &quot;BBC2&quot; ... ## $ ep_id : num [1:94] 1 2 3 4 5 6 7 8 9 10 ... The values just after the \":\" tells us the type of each variable num stands for numeric variable Date stands for a type of variable that can handle calendar dates chr stands for 'character' which usually represents a categorical variable Because numbers (e.g. the values that series takes, i.e. 1, 2, 3, ...) can also represent 'categories' or 'levels' of a categorical variable, R doesn't assume that just because a variable is of type chr that it is categorical. To specify a categorical variable in R we use the as.factor() function, since R calls categorical variables \"factors\". In the ratings data at least the three variable series, episode and channel are categorical variables but they aren't stored as such, yet! To make categorical variables into factors, we will use some key functions in the dplyr package (part of the tidyverse). To tell R that variables are factors (i.e. categorical) use mutate() to overriding the original variable with the same data but classified as a factor. Copy and run this code to change the series and episode variables to factors. ratings &lt;- ratings %&gt;% mutate(series = as.factor(series), episode = as.factor(episode), channel = as.factor(channel)) str(ratings) ## tibble [94 × 13] (S3: tbl_df/tbl/data.frame) ## $ series : Factor w/ 10 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 1 1 1 1 1 1 2 2 2 2 ... ## $ episode : Factor w/ 10 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 1 2 3 4 5 6 1 2 3 4 ... ## $ uk_airdate : Date[1:94], format: &quot;2010-08-17&quot; &quot;2010-08-24&quot; ... ## $ viewers_7day : num [1:94] 2.24 3 3 2.6 3.03 2.75 3.1 3.53 3.82 3.6 ... ## $ viewers_28day : num [1:94] 7 3 2 4 1 1 2 2 1 1 ... ## $ network_rank : num [1:94] NA NA NA NA NA NA NA NA NA NA ... ## $ channels_rank : num [1:94] NA NA NA NA NA NA NA NA NA NA ... ## $ bbc_iplayer_requests: num [1:94] NA NA NA NA NA NA NA NA NA NA ... ## $ episode_count : num [1:94] 1 2 3 4 5 6 7 8 9 10 ... ## $ us_season : num [1:94] NA NA NA NA NA NA NA NA NA NA ... ## $ us_airdate : chr [1:94] NA NA NA NA ... ## $ channel : Factor w/ 3 levels &quot;BBC1&quot;,&quot;BBC2&quot;,..: 2 2 2 2 2 2 2 2 2 2 ... ## $ ep_id : num [1:94] 1 2 3 4 5 6 7 8 9 10 ... You can read this code as, for example, \"overwrite the data that is in the column series with series as a factor, thus converting it to a categorical variable\". Remember this. It's a really important step and if graphs are looking weird this might be the reason. Now, let us explore more some variables of interest. The variables we will analyse in this lab are: series: the series number, ranging from 1 to 10 corresponding to 2010-2019. episode: the episode number, randing from 1 to 10 (although not all series had 10 episodes!) viewers_7day the ratings of each episode in the 7 day period after its broadcast (measured as millions of viewers) Run this code to just see the viewers_7day values in the ratings data: ratings$viewers_7day ## [1] 2.240 3.000 3.000 2.600 3.030 2.750 3.100 3.530 3.820 3.600 ## [11] 3.830 4.250 4.420 5.060 3.850 4.600 4.530 4.710 4.610 4.820 ## [21] 5.100 5.350 5.700 6.740 6.600 6.650 7.170 6.820 6.950 7.320 ## [31] 7.760 7.410 7.410 9.450 8.510 8.790 9.280 10.250 9.950 10.130 ## [41] 10.280 9.023 10.670 13.510 11.620 11.590 12.010 12.360 12.390 12.000 ## [51] 12.350 11.090 12.650 15.050 13.580 13.450 13.010 13.290 13.120 13.130 ## [61] 13.450 13.260 13.440 15.900 9.460 9.230 8.680 8.550 8.610 8.610 ## [71] 9.010 8.950 9.030 10.040 9.550 9.310 8.910 8.880 8.670 8.910 ## [81] 9.220 9.690 9.500 10.340 9.620 9.380 8.940 8.960 9.260 8.700 ## [91] 8.980 9.190 9.340 10.050 What do the numbers in square brackets represent in the output to ratings$viewers_7day? They are part of the data set, i.e. more values of ratings. They don't really have any important meaning. They represent the time taken to run the code in miliseconds. They represent the position of the ratings in the output. i.e. [1] preceeds the first ratings value, [21] preceeds the 21st ratings value.       3.2.4 Creating summaries of data 3.2.4.1 Categorical Data Let us start creating some summaries of categorical variables. Identify the type of each of the variables in the ratings data: series: ordinalcontinuousnominaldiscrete episode: ordinalcontinuousnominaldiscrete viewers_7day discretecontinuousnominalordinal channel discretecontinuousnominalordinal The count() function counts the number of rows that are the same. This will give you a new table with each combination of the counted rows and a column called n containing the number of observations from that group. The first argument that count() takes is the data object to summarise The next arguments that count() takes are the variables to summarise The argument sort = TRUE will sort the table by n in descending order. Run this code and answer the following question: count(ratings, channel, sort = TRUE) Which channel screened the most episodes of GBBO from 2010 to 2019? BBC1BBC2Channel 4No single channel Run this code and answer the following questions: count(ratings, channel, series) What is this summary revealing? The number of series within each episode (together with what channel broadcast that series) The number of series within each episode The number of episodes within each series The number of episodes within each series (together with what channel broadcast that series) How could the order of the columns in the summary table be changed? count(ratings, series, episode) count(ratings, episode, channel) The order can't be changed count(ratings, series, channel) 3.2.4.2 Numerical Data The summarise() function from the dplyr package is loaded as part of the tidyverse and creates summary statistics. It creates a new object with columns that summarise the data from a larger table using summary functions. Check this Cheat Sheet for various summary functions. Some common ones are: n(), min(), max(), mean(), sd() and quantile(). Here is an example using summarise() summarise(ratings, mean_ratings = mean(viewers_7day), sd_ratings = sd(viewers_7day), min_ratings = min(viewers_7day), max_ratings = max(viewers_7day)) ## # A tibble: 1 × 4 ## mean_ratings sd_ratings min_ratings max_ratings ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 8.58 3.27 2.24 15.9 The first argument that summarise() takes is the data object to summarise summarise() creates a new object. The column names of this new object are on the left hand-side of =, i.e., mean_ratings, sd_ratings, min_ratings and max_ratings. The values of these columns are the result of the summary operation on the right hand-side of =. What is the average number of viewers that GBBO had in the 7 days after broadcast? 3270000 2240000 8580000 15900000 What is the least number of viewers that GBBO had in the 7 days after broadcast: What is the most viewers that GBBO had in the 7 days after broadcast: "],["group-tasks.html", "4 Group Tasks 4.1 BFRSS Survey Questions", " 4 Group Tasks The group tasks in this lab will not be assessed, however they do offer good practice in writing your own code in R. 4.1 BFRSS Survey Questions The Behavioral Risk Factor Surveillance System (BRFSS) is an annual telephone survey of 350,000 people in the United States. As its name implies, the BRFSS is designed to identify risk factors in the adult population and report emerging health trends. For example, respondents are asked about their diet and weekly physical activity, possible tobacco use, and even their level of healthcare coverage. The BRFSS Web site contains a complete description of the survey, including the research questions that motivate the study and many interesting results derived from the data. You will focus on a random sample of 20,000 people from the BRFSS survey conducted in 2000. While there are over 200 variables in this data set, you will work with a small subset. Load the data set of 20,000 observations into the object cdc and look at what it contains by running the following code. It may take a couple of minutes for the data to load, depending on your internet connection, so be patient! Remember to create a new R Script to run your code! source(&quot;http://www.openintro.org/stat/data/cdc.R&quot;) str(cdc) Observe the structure of the data. How many variables are numerical? How many are categorical? Find the mean, maximum and minimum values of weight (weight). Hint For this task you can use summarise() as we did in Section 3.2.4.2. 3a. Let's consider a new variable: the difference between desired weight (wtdesire) and current weight (weight). Create this new variable by subtracting the two columns in the data frame and assigning them to a new object called wdiff. Hint You can access columns using the $ operator. Hint 2 To create the new column recall the assign operator: &lt;- 3b. Create the same object, wdiff, but this time add it to the cdc data set. Hint Recall the mutate function What type of data is wdiff? If an observation wdiff is 0, what does this mean about the person's weight and desired weight. What if wdiff is positive or negative? "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
